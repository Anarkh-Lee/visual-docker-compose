import { useState, useCallback } from 'react';

export interface EnvVariable {
  key: string;
  value: string;
  isSecret: boolean;
}

export function useEnvVariables() {
  const [envVariables, setEnvVariables] = useState<EnvVariable[]>([]);

  const addVariable = useCallback(() => {
    setEnvVariables((prev) => [
      ...prev,
      { key: '', value: '', isSecret: false },
    ]);
  }, []);

  const updateVariable = useCallback((index: number, field: keyof EnvVariable, value: string | boolean) => {
    setEnvVariables((prev) => {
      const updated = [...prev];
      if (field === 'key' && typeof value === 'string') {
        updated[index] = { ...updated[index], key: value.toUpperCase() };
      } else {
        updated[index] = { ...updated[index], [field]: value };
      }
      return updated;
    });
  }, []);

  const removeVariable = useCallback((index: number) => {
    setEnvVariables((prev) => prev.filter((_, i) => i !== index));
  }, []);

  const parseEnvText = useCallback((text: string) => {
    const lines = text.split('\n');
    const variables: EnvVariable[] = [];

    lines.forEach((line) => {
      const trimmed = line.trim();
      // Skip empty lines and comments
      if (!trimmed || trimmed.startsWith('#')) return;

      const eqIndex = trimmed.indexOf('=');
      if (eqIndex > 0) {
        const key = trimmed.substring(0, eqIndex).trim().toUpperCase();
        let value = trimmed.substring(eqIndex + 1).trim();
        
        // Remove surrounding quotes if present
        if ((value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))) {
          value = value.slice(1, -1);
        }

        if (key) {
          variables.push({
            key,
            value,
            isSecret: key.toLowerCase().includes('password') || 
                      key.toLowerCase().includes('secret') ||
                      key.toLowerCase().includes('token') ||
                      key.toLowerCase().includes('key'),
          });
        }
      }
    });

    setEnvVariables(variables);
  }, []);

  const toEnvText = useCallback((): string => {
    return envVariables
      .filter((v) => v.key.trim())
      .map((v) => {
        const value = v.value.includes(' ') || v.value.includes('"') 
          ? `"${v.value.replace(/"/g, '\\"')}"` 
          : v.value;
        return `${v.key}=${value}`;
      })
      .join('\n');
  }, [envVariables]);

  const generateEnvFile = useCallback((): string => {
    const header = '# Environment variables for Docker Compose\n# Generated by Visual Docker Compose Builder\n\n';
    return header + toEnvText();
  }, [toEnvText]);

  const downloadEnv = useCallback(() => {
    const content = generateEnvFile();
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = '.env';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [generateEnvFile]);

  const clearAll = useCallback(() => {
    setEnvVariables([]);
  }, []);

  return {
    envVariables,
    setEnvVariables,
    addVariable,
    updateVariable,
    removeVariable,
    parseEnvText,
    toEnvText,
    generateEnvFile,
    downloadEnv,
    clearAll,
  };
}
